#This script bootstraps the post data analysis of the citrus tree example
#
#library(MASS)
lm.rEV.lib <-function(){#lm.rEV uses function from these libraries
  library(stringr) #rational string functions
  library(foreach)  # iteration and looping compatible with parallel processing
  library(plyr)  #rational wrapper for apply like functions
  library(doFuture) #parallel processing back end
  library(kde1d) # spline smoothed kernel density estimation
}
library(tictoc) #used for timing.  not essential
lm.rEV.lib() #loads libraries

DelSIC.RA <- function(mR,mA){ #basic relative evidence function DelSIC.RA
  #compares evidence for a reference model (mR) relative to another model (mA)
  #Positive value is evidence for mR over mA
  #model obj must be one that is recognized by stats::BIC
  out <- BIC(mA)-BIC(mR) 
  return(out)
}

#shazam sets up doFuture parallel backend
shazam <- function(pln="multisession"){# sets up doFuture parallel backend 
  ##------ "2024-06-14 11:22:32 MDT" ------##
  # does a garbage collection and then resets doFuture parallel processing back sets processing to one of
  # multisession, sequential, ms.nested, sm.nested
  # plans can be abreviated by partial matching to one of ("mu","se","ms","sm")
  # if pln is a numeric value, as.integer(abs(pln)) workers will be created
  #code by Mark L. Taper <MarkLTaper@gmail.com>
  check_and_load <- function(package) {
    if (!require(package, character.only = TRUE)) {
      if (!requireNamespace(package, quietly = TRUE)) {
        stop(paste("The package", package, "is not installed. Please install it to use this function."))
      } else {
        library(package, character.only = TRUE)
      }
    }
  }
  check_and_load("doFuture")
  
  gc() #garbage collection
  doFuture::registerDoFuture()
  if (is.numeric(pln)){
    wrkrs <- as.integer(abs(pln))
    plan(multisession,workers=wrkrs)
  } else { switch(  pmatch(pln,table = c("sequential","multisession","ms.nested","sm.nested")),
           sequential=plan(future::sequential),
           multisession=plan(future::multisession),
           ms.nested=plan(list(multisession, sequential)),
           sm.nested=plan(list(sequential,multisession))
          )
  }
  cat("DoFuture parallel processing backend with",getDoParWorkers(),"workers\n")
  if (getDoParWorkers() > availableCores()) {
    cat("---You are using more workers than you have cores.\n---This will create virtual workers and degrade performance")
  }
}#end of shazam


lm.rEV <- function(mR,mA,.DATA,Xmod=NA,strta=NA,Breps=2000,
                   Btyps=c("prmRBt","prmABt","resBt","strtBt"),VI=TRUE,incl_bt0=TRUE,
                   rEV.lim=c(0.01,100),rEV.conf.lev=c(0.05,0.5,0.95),k=c(-7,7),
                   rEV.fun=NA,resCenter=median,sz.out.lev=1) {
  {# function opening documentation
    #mR is reference model positive values of evidence support mR over mA
    #mA is alternative model negative values of evidence support mA over mR
    #parmod is model used to generate .DATA in the parametric bootstrap.  All factors and covariates used by parmod must be supplied in .DATA
    #mR,mA, and parmod can be either formula or fitted model
    # Xmod can be a user supplied function with arguments (.DATA=.DATA,i=i) and return value (DATA.i)
    #  all other variables used by a user defined parmod must be supplied in the input .DATA.frame .DATA 
    #The response variable DATA.i for mR & mA should be modified by Xmod 
    #Xmod can be a lm but is not restricted as such.
    #strta integer vector or factor of cell identities for stratified bootstrap
    #strta can be generated by base::interaction. 
    #strta can be specified as a string that the name of an appropriate variable in .DATA
    #If not specified strta will be generated base on the factors of the model with smallest RSS
    #strta will be added to .DATA with the name ".grps"
    #Btyps is a character vector whose elements match types of bootstraps to be used.
    #prmRBt <- parametric bootstrap from estimated mR
    #prmABt <- parametric bootstrap from estimated mA
    #prXBt <-  parametric bootstrap from an externally supplied Xmod. "prXBt" will be added to Btyps if !is.na(Xmod)
    #resBt <- un-stratified residual bootstrap
    #strtBt <- stratified residual bootstrap
    #VI is a boolean variable controlling bootstrap .DATA is created using variance-inflated residuals or unaltered residuals 
    #rEV.lim specifies the rows of rEV.cdf output object
    #rEV.lim of length 2: range of probabilities (rEv.lim[1],1-rEV.lim[1]), dim(rEV.cdf)[1]=rEV.lim[2]
    #rEV.lim of length 3: rEV.lim[1]=min quantile, rEV.lim[2]=max quantile, rEV.lim[3]=dim(rEV.cdf)[1]
    #rEV.lim of length >3: rEV.lim is a vector of quantiles for rEV.cdf
    #vector of quantiles rEV.q is created based on rEV.lim
    #rEV.conf.lev specifies levels (1 sided) for confidence interval construction on the evidence 
    #k is a vector of evidence thresholds, of length 2,4, or 6. k needs to be ordered with half of the values negative
    #with 2 levels k[1] is the strong evidence threshold for mA over mR and k[2] is the strong evidence threshold for mR over mA
    #with 4 levels k[1] & k[2] are the strong and prognostic threshold for evidence for mA over mR,
    # k[3] and k[4] is are the prognostic and strong thresholds for evidence for mR over mA.
    # with 6 levels these will be the very strong, strong, prognostic, prognostic, strong, and very strong thresholds
    #rEV.fun is the evidence function to be used. if NA DelSIC.RA is used
    #resCenter is the central value function used in creating residuals 
    #sz.out.lev the size of the output object.  This may be important with large simulations using lm.rEV
    #sz.out.lev one of 1,2,3,4.  1=complete return object. 2 -> Bootstrap data not saved in kde objects
    #sz.out.lev 3 -> grid_points vectors in kde objects collapsed. This can be reversed using xpnd.grid_points
    #sz.out.lev 4 -> Does not include any kde objects in the return value.
    #If a custom function is used, it must take two lm objects as arguments i.e rEV.fun(mR,mA)
    #resCenter is the function used to create residuals. its argument is numeric vector of length >0
    #rEV.kde.lst a list of the kde1d object for all requested bootstrap types
    #theses object will be named prmBt, resBt, and strtBt
    #aR is a named vector of the apparent reliability of model identification as calculated each bootstrap evidence cdf
    #P a list of PmA and PmR. PmA=P(ev.sim > ev.observed |generated from mA). PmR=P(ev.sim < ev.observed |generated from mR)
    #pk a matrix which holds for each bootstrap type requested the proportion of evidence falling below each evidence threshold
    #EV.class.prop a matrix which holds for each bootstrap type requested the proportion of evidence falling below each evidence threshold
    #EV.class.prop is just an alternative representation of pk
    #DKest is the estimated difference in KL divergences to the generating process DKest=rEV/nobs
    #rEV.cdf.mat a matrix whose first column is rEV.q a vector of quantiles of relative evidence
    #columns 2 and 3, and 4 are cummulative probabilities at each of the quantiles given by column 1 for each bootstrap type.
    #rEV.CI.mat a matrix whose first column is rev.conf.lev
    #columns 2 and 3, and 4 are the quantiles at each of the probability levels given by colum 1 for each bootstrap type.
    #call contains all objects specified by lm.rEV arguments including the models
    #return value list(rEV,DKest,rEV.CI.mat,DKest.CI.mat,rEV.cdf.mat, rEV.kde.lst,DKest.kde.lst, call, version)
    #version 0.1  "2024-06-07 16:07:16 MDT"
    #version 0.2  "2024-06-15 17:02:53 MDT": DKest, DKest.CI.mat, DKest.kde.lst and sz.out.lev added
    #version 0.3 "2024-06-28 16:49:21 MDT": aR,P,pk, EV.class.prop added
  }#end function opening documentation
  
  {#utility functions
    
    balsmpl3 <- {  function( #generates indicies for a balanced bootstrap
      B,           # number of bootstraps desired
      sz.strata=NULL,     # number of observations in .DATAset to be bootstrapped
      # or vector of group indicators
      incl_bt0=T,  # include original .DATA as a bootstrap
      rwname="bt"  # prefix for rownames for bootstraps
    ) # end of function arguments
    { #function body
      {# Header documentation
        #Generates indicies for a balanced bootstrap (unstratified of stratified)
        #All indicies occur equal number of times in matrix
        #Balanced bootstraps are more efficient than regular bootstraps
        #Use each row of the matrix to select a bootstrapped sample
        #Each row (i.e. bootstrap) is given an identifier in the rowname e.g. "bt324"
        #strata does not need to be sorted
        #One and only one of sz or strata must be given
        #k allows for .DATA-cloning like inflation of .DATA set size
        #Returns a (B)X(k*sz) matrix of indices for a balanced bootstrap if incl_bt0=F.
        #Returns a (B)X(k*sz) matrix of indices for a balanced bootstrap if incl_bt0=T.
        #If incl_b0=T then first row is 1:sz (i.e original estimate)
        #This function replaces balsmpl, and behaves the same if sz is given and k=1.
        #Version 2 adds .DATA cloning facility and changes the behavior when incl_bt0=T
        #  num of output rows now = B regardless of value of incl_bt0 version 1 had B+1 rows
        #version 3 simplifies bootstrap control with a single argument, sz.strata. If this has length 1
        # sz.strata specifies sz. If length(sz.strata)>1 then sz.strata specifies strata.
        # version 3 also drops .DATA cloning, and removes k argument
        # version 4 allows sz.strata to be a factor by converting to an integer vector internally
        # Version 1: "2019-05-03 19:44:05 MDT"
        # Version 2: "2019-12-10 10:56:11 MST"
        # version 3:  "2023-09-03 17:17:35 MDT"
        # version 4:  "2024-06-06 11:07:20 MDT"
        #code by Mark L. Taper <MarkLTaper@gmail.com>
      } # end Header documentation
      
      { # utility functions for balsmpl3
        balsmpli <- function(B,idvec,rwname="bt"){
          #"2019-04-20" by Mark L. Taper
          #Modified balsmpl.  Samples from a vector of indexes rather than assuming 1:sz
          #specifying idvec=1:sz gives same behavior as balsmpl
          #Returns a B X length(idvec) matrix of indices for a balanced bootstrap if bt0=F.
          #Returns a (B) X length(idvec) matrix of indices for a balanced bootstrap if bt0=T.
          #All indicies occur = number of times in matrix
          #Balanced bootstraps are more efficient than regular bootstraps
          #Use each row of the matrix to select a bootstrapped sample
          #Each row (i.e. bootstrap) is given an identifier in the rowname e.g. "bt324"
          #If incl_b0=T then first row is 1:sz if sz is scalar or sz if sz is vector
          # if (incl_bt0) {
          #   if (B==1){
          #     out <- matrix(idvec,nrow=1)
          #   } else {
          #     idxes=sample(rep(idvec,times = B-1))
          #     out=matrix(idxes,nrow=B-1)
          #     out <-rbind(1:length(idvec),out)
          #     rownames(out) <- stringr::str_c(rwname,0:(B-1),sep = "")
          #     
          #   }
          # } else
          {
            idxes=sample(rep(idvec,times = B))
            out=matrix(idxes,nrow=B)
            rownames(out) <- stringr::str_c(rwname,1:B,sep = "")
            
          }
          return(out)
        } #makes indecies for a balanced bootstrap
        
      } # end of balsmpl3 utility functions
      
      { # checks and initialization
        if (is.null(sz.strata)) stop("one of sz or strata must be given")
        if (incl_bt0 & (B==1)) warning("(incl_bt0 & (B==1)) This may not be what you want")
        if (length(sz.strata)==1) { #sz.strata is size
          sz=sz.strata
          strata <- rep(1,sz) 
        } else {
          sz <- length(sz.strata) #.DATA set number of rows
          strata=as.integer(sz.strata) #as.integer allows use of factors MLT 6/6/24
        }
        univl <- unique(strata) #unique values in strata
        num_strt <- length(univl) # number of strata
        idx_strt <- cbind(1:sz,strata)
        colnames(idx_strt) <- c("idx", "strt")
        out <- NULL
      } # end of checks and initialization
      
      if (incl_bt0) {
        Binternal <- B-1
      } else {
        Binternal <- B
      }
      for (s in univl){ # build bootstrap indicies by strata
        idvec <- idx_strt[idx_strt[,"strt"]==s,,drop=FALSE][,"idx"] 
        btmat_s <- balsmpli(B=Binternal,idvec=idvec,rwname = rwname)
        out <- cbind(out,btmat_s)
      } # end of build bootstrap indicies by strata
      
      if (incl_bt0) {
        out <-rbind(1:sz,out)
        rownames(out) <- stringr::str_c(rwname,0:(B-1),sep = "")
      }
      
      
      
      return(out)
    }
    }# end of function balsmpl3
    #function balsmpl3 generates indicies for a balanced bootstrap
    
    
    n.in.grp <- function(grps){
      #function finds the size of cell that each observation ocurrs ing
      #out is a vector with the same length as grps.
      #out[i] is the count of the number of time grps[i] occurs in grps
      grps <- as.factor(grps) #making sure that grps is a factor
      numObs <- length(grps)
      byob <- rep(NA,numObs)
      bygrp <- plyr::count(grps)
      colnames(bygrp)[1] <- "grp"
      for (i in 1:numObs) {
        grp <- grps[i]
        byob[i] <- bygrp[which(bygrp$grp==grp),2]
      }
      out <- list(byob=byob,bygrp=bygrp)
      return(out)
    }# end of n.in.grp
    
    RSS <-  function(lm.obj){
      #residual sum of squares
      out <- sum(residuals(lm.obj)^2)
      return(out)
    }# end of RSS
    
    MSE <- function(lm.obj) {
      #mean squared error. (unbiased estimate, uses df in denominator
      out <- RSS(lm.obj)/lm.obj$df.residual
      return(out)
    }# end of MSE
    
    RSE <- function(lm.obj) {
      #residual standard error (unbiased standard deviation)
      out <- sqrt(MSE(lm.obj))
      return(out)
    }# end of MSE
    
    mkstrta <- function(lm.obj,.DATA) {
      #code created interacting with copilot
      terms <- attr(terms(lm.obj), "term.labels") # Extract the terms
      factor_names <- c() # Initialize an empty vector to hold the factor names
      for (term in terms) {# For each term
        if (grepl(":", term)) {         # If the term is an interaction
          factors <- unlist(strsplit(term, ":"))# Split the term into the interacting factors
          factor_names <- c(factor_names, factors) # Add the factors to the factor_names vector
        } else { # If the term is not an interaction, add it to the factor_names vector
          factor_names <- c(factor_names, term)
        }
      }
      factor_names <- unique(factor_names) # Remove duplicates
      factor_.DATA <- .DATA[factor_names] # Create a new .DATA frame with only the factor variables
      factor_.DATA <- factor_.DATA[sapply(factor_.DATA, is.factor)]       # Exclude non-factor variables
      interaction_factor <- interaction(factor_.DATA, drop=TRUE) # Create a factor of the interaction of all factors
      return(interaction_factor)
    }
    
    
    DelSIC.RA <- function(mR,mA){ #basic evidence function DelSIC.RA
      #Positive value is evidence for mR over mA
      #model obj must be one that is recognized by stats::BIC
      out <- BIC(mA)-BIC(mR) 
      return(out)
    }
    
    coerce2df <- function(object) {
      #as..DATA.frame that throws an error if result is not recognizable as df
      tryCatch({
        df <- as.data.frame(object)
        coerceOK <- is.data.frame(df)
      }, error = function(e) {
        coerceOK <- FALSE
      })
      if (coerceOK==FALSE) {stop("input .DATA cannot be cannot be coerced to .DATAframe")}
      return(df)
    }  # end coerce2df
    
    mk.DATA.i <- function(Btp,DAT,idx,Bt.idx=NA) {
      DATA.i <- DAT
      if (str_detect(Btp,"R")){#Btp matches "prmRBt"
        DATA.i[,respns] <- DATA.i$.cntr + rnorm(n=rows.DATA,mean = 0,sd = mR.Rse)
      }
      if (str_detect(Btp,"A")){#Btp matches "prmBt"
        DATA.i[,respns] <- DATA.i$.cntr + rnorm(n=rows.DATA,mean = 0,sd = mA.Rse)
      }
      if (str_detect(Btp,"X")){#Btp matches "prXBt"
        DATA.i[,respns] <- Xmod(DATA.i)
      }
      
      if ( str_detect(Btp,"s")){#Btyp matches "resBt" or "strtBt"
        #note the two bootstraps differ by how Bt.idx has been built
        if (VI) { #use inflated
          DATA.i[,respns] <- DATA.i$.cntr + DATA.i$.VIres[Bt.idx[idx,]]
        } else { # use un-inflated residual
          DATA.i[,respns] <- DATA.i$.cntr + DATA.i$.res[Bt.idx[idx,]]
        }
      }# end Btyp matches "resBt" or "strtBt"
      out <- DATA.i
      return(out)
    } # end mkDATA.i
    
    
    mk.cdf.mat <- function(kde.lst,rEV.lim) {
      Btyps <- names(kde.lst)
      lim.typ=3 # prespecified rEV.q
      if (length(rEV.lim)==2) {lim.typ <- 1} # p and length specified rEV.q
      if (length(rEV.lim)==3) {lim.typ <- 2} # min, max, and length specified rEV.q
      cdf.mat.cols <- numBtyps + 1
      cdf.mat.rows <- switch(lim.typ, rEV.lim[2], rEV.lim[3],length(rEV.lim))
      cdf.mat <- matrix(NA,nrow=cdf.mat.rows,ncol=cdf.mat.cols) 
      colnames(cdf.mat) <- c("rEV.q",Btyps)
      if (lim.typ==1) {
        minp <- rEV.lim[1]
        maxp <- 1-minp
        xlm=NULL
        for (Btyp in Btyps){
          xlm <- c(xlm,kde1d::qkde1d(p=c(minp,maxp),obj=kde.lst[[Btyp]]))  
        }
        rEV.q <- seq(from=min(xlm),to=max(xlm),length.out=rEV.lim[2])
      }
      if (lim.typ==2) {rEV.q <- seq(from=rEV.lim[1],to=rEV.lim[2],by=rEV.lim[3])}       
      if (lim.typ==3) {rEV.q <- rEV.lim} 
      cdf.mat[,"rEV.q"] <- rEV.q
      for (Btyp in Btyps){
        cdf.mat[,Btyp] <- kde1d::pkde1d(q = rEV.q,obj = kde.lst[[Btyp]])
      }
      return(cdf.mat)
    }#end mk.cdf.mat
    
    mk.CI.mat <- function(kde.lst=rEV.kde.lst,conf.lev=rEV.conf.lev){
      out <- matrix(NA,nrow=length(conf.lev),ncol=(length(kde.lst)+1))
      colnames(out) <- c("conf.lev",names(kde.lst))
      out[,1] <- conf.lev
      for (nm in names(kde.lst)){
        out[,nm] <- kde1d::qkde1d(p=conf.lev,obj=kde.lst[[nm]])
      }
      return(out)
    }
    
    reduceSz.kde <- function(kde.obj,sz.lv) {
      #if grid_points removed by sz.lv = 3, they can be put back in by applying xpnd.grid_points
      out <- kde.obj
      if (sz.lv ==2){out$x <- range(kde.obj$x)} #discards data except for lowest and highest values
      if (sz.lv ==3){
        out$x <- range(kde.obj$x)
        out$grid_points <- range(kde.obj$grid_points) # also discards grid_points except for lowest and highest values
      } 
      return(out)
    }
    
  }#end utility functions
  
  {#setup
    ver <- "lm.rEV.boot version 0.3"
    #    if(!exists(.DATA)) {stop(".DATA is a required argument")}
    .DATA <- coerce2df(.DATA) #stops if .DATA cannot be coerced to a recognizable .DATA.frame
    rows.DATA <- dim(.DATA)[1]#rows.DATA holds number of observations
    
    if (!inherits(mR, "lm")) {
      if (is.formula(mR)){
        mR <- lm(formula = mR,.DATA=.DATA)
      } else {stop("mR is neither a lm object nor a formula")}
    } 
    respns=as.character(formula(mR))[2]
    respnsA = as.character(formula(mA))[2]
    if (respns != respnsA) {stop("mR response variable != mA response variable")}
    if (!inherits(mA, "lm")) {
      if (is.formula(mA)){
        mA <- lm(formula = mA,.DATA=.DATA)
      } else {stop("mA is neither a lm object nor a formula")}
    } 
    
    mR.RSS <- RSS(mR)
    mA.RSS <- RSS(mA)
    mR.Rse <- RSE(mR)
    mA.Rse <- RSE(mA)
    
    if (any(str_detect(names(.DATA),".grps"))){
      if(any(is.na(strta))) {
        stop("A variable named '.grps' exists in .DATA and has not be identified as strta")
      } #this is a clumsy way around the NA possibility
      if(strta != ".grps"){
        stop("A variable named '.grps' exists in .DATA and has not be identified as strta")
      }
    } else {
      if (any(is.na(strta))) {
        if (mR.RSS < mA.RSS) {
          strta <- mkstrta(mR,.DATA)
        } else {
          strta <- mkstrta(mA,.DATA)
        }
        .DATA$.grps <- strta #".grps" is the stratifying variable
      } else {
        if (is.factor(strta)){#input strta is a factor
          if (length(strta) != rows.DATA){
            stop("strta must either be 'NA', string identifying a factor in .DATA, or be a factor of compatible length")
          }
          .DATA$.grps <- strta #".grps" is the stratifying variable
        } else { # strat not NA or a factor
          if (is.character(strta) && any(str_detect(names(.DATA),strta)) && is.factor(.DATA[,strta])){
            .DATA$.grps <- .DATA[,strta] #".grps" is the stratifying variable
          } else{
            stop("strta must either be 'NA', string identifying a factor in .DATA, or be a factor of compatible length")
          } 
        }
      }
    }#end of checks on strta. .DATA$.grps constructed if all checks passed
    
    if (any(str_detect(names(.DATA),".strat.sz"))){
      stop("A variable named '.strat.sz' exists in .DATA. this is a reserved name and might create conflict")
    }
    if (any(str_detect(names(.DATA),".cntr"))){
      stop("A variable named '.cntr' exists in .DATA. this is a reserved name and might create conflict")
    }
    if (any(str_detect(names(.DATA),".res"))){
      stop("A variable named '.res' exists in .DATA. this is a reserved name and might create conflict")
    }
    if (any(str_detect(names(.DATA),".VIres"))){
      stop("A variable named '.VIres' exists in .DATA. this is a reserved name and might create conflict")
    }
    
    if (!is.na(Xmod)){
      if (!is.function(Xmod)){
        stop("argument Xmod must be either NA or a function")
      }
      Btyps <- c(Btyps,"prXBt") #including externally supplied model in the list of bootstrap types
    }
    
    #  if (any(str_detect(Btyps,pattern = "p"))) {
    #   if ((length(parmod) == 1) && is.na(parmod)){
    #     if (mR.RSS < mA.RSS){
    #       parmod <- mR
    #     } else { parmod <- mA}
    #   }
    #   if (!inherits(parmod, "lm")) {
    #     if (is.formula(parmod)){
    #       parmod <- lm(formula = parmod,.DATA=.DATA)
    #     } else {stop("parmod is neither a lm object nor a formula")}
    #   }
    #   parmod.Rse <- sqrt(MSE(parmod)) #extract residual standard error. works for either aov or lm
    # 
    # }
  
    if (!is.function(rEV.fun)){
      if(is.na(rEV.fun)){
        rEV.fun <- DelSIC.RA
      } else {
        stop("rEV.fun must be either NA or a function")
      }
    }
    
    .DATA <- .DATA[order(.DATA$.grps),] #observations in the same cell are now in contiguous rows
    numBtyps <-  length(Btyps)
    rEV.kde.lst <- vector(mode = "list",numBtyps)
    names(rEV.kde.lst) <- Btyps
    DKest.kde.lst <- rEV.kde.lst
    rEV.boot.lst <- vector(mode = "list",numBtyps)
    names(rEV.boot.lst) <- Btyps
    {#some of these statements may not work properly if .DATA has not been ordered by .grps
      grp.cntr <- as.vector(by(data = .DATA[,respns],INDICES =.DATA$.grps,FUN = resCenter ))
      grp.sz <- n.in.grp(.DATA$.grps)$bygrp[,"freq"]
      .DATA$.strat.sz <- n.in.grp(.DATA$.grps)$byob
      .DATA$.cntr <- rep(grp.cntr,times=grp.sz)
      .DATA$.res <- .DATA[,respns] - .DATA$.cntr
      .DATA$.VIres <- .DATA$.res*sqrt(.DATA$.strat.sz/(.DATA$.strat.sz-1)) #variance inflation
    }
    wrkrs <- getDoParWorkers()
    blksz=Breps/wrkrs #used for chunking parallel processing
    
  }#end setup
  
  {# function body
    rEV <- rEV.fun(mR,mA)
    models <- list(mR=mR,mA=mA)
    DKest <- rEV/rows.DATA
    for (Btyp in Btyps) {
      if (str_sub(str_to_lower(Btyp),start = 1,end = 1)=="p") {#parametric bootstrap
        
        rEV.boot.lst[[Btyp]] <- foreach(i=1:Breps,.combine = c,.inorder = F,
                                        .errorhandling = "remove",
                                        .options.future = list(chunk_size = blksz,seed = TRUE))%dofuture%{
                                          DATA.i <- mk.DATA.i(Btp = Btyp,DAT = .DATA,idx=i,Bt.idx=NA)
                                          mA.i <- lm(formula = formula(mA),data=DATA.i)
                                          mR.i <- lm(formula = formula(mR),data=DATA.i)
                                          out <- rEV.fun(mR=mR.i,mA=mA.i)
                                          return(out)
                                        }
      } # end parametric boostratp
      if (str_sub(str_to_lower(Btyp),start = 1,end = 1)=="r") {#un-stratified residual bootstrap
        
        Bt.dx <- balsmpl3(B=Breps,sz.strata = rows.DATA,incl_bt0 = incl_bt0) #unstructured bootstrap
        rEV.boot.lst[[Btyp]] <- foreach(i=1:Breps,.combine = c,.inorder = F,
                                        .errorhandling = "remove",
                                        .options.future = list(chunk_size = blksz,seed = TRUE))%dofuture%{
                                          DATA.i <- mk.DATA.i(Btp = Btyp,DAT = .DATA,idx=i,Bt.idx=Bt.dx)
                                          mA.i <- lm(formula = formula(mA),data=DATA.i)
                                          mR.i <- lm(formula = formula(mR),data=DATA.i)
                                          out <- rEV.fun(mR.i,mA.i)
                                          return(out)
                                        }
      } # end un-stratified residual bootstrap
      if (str_sub(str_to_lower(Btyp),start = 1,end = 1)=="s") {#stratified residual bootstrap
        
        Bt.dx <- balsmpl3(B=Breps,sz.strata = .DATA$.grps,incl_bt0 = incl_bt0) #statified bootstrap
        rEV.boot.lst[[Btyp]] <- foreach(i=1:Breps,.combine = c,.inorder = F,
                                        .errorhandling = "remove",
                                        .options.future = list(chunk_size = blksz,seed = TRUE))%dofuture%{
                                          .DATA.i <- mk.DATA.i(Btp = Btyp,DAT = .DATA,idx=i,Bt.idx=Bt.dx)
                                          mA.i <- lm(formula = formula(mA),data=.DATA.i)
                                          mR.i <- lm(formula = formula(mR),data=.DATA.i)
                                          out <- rEV.fun(mR.i,mA.i)
                                          return(out)
                                        }
      } # end stratified residual bootstrap
    }# end for (Btyp in Btyps) 
    
    for (Btyp in Btyps){
      rEV.kde.lst[[Btyp]] <- kde1d::kde1d(rEV.boot.lst[[Btyp]])
      DKest.kde.lst[[Btyp]] <- kde1d::kde1d(rEV.boot.lst[[Btyp]]/rows.DATA)
    }
    
    
  } #end function body
  
  {# make return value
    rEV.cdf.mat <- mk.cdf.mat(kde.lst = rEV.kde.lst,rEV.lim = rEV.lim)
    rEV.CI.mat <- mk.CI.mat(kde.lst=rEV.kde.lst,conf.lev=rEV.conf.lev)
    DKest.CI.mat <- mk.CI.mat(kde.lst=DKest.kde.lst,conf.lev=rEV.conf.lev)
    
    aR <- rep(NA,length(Btyps))
    names(aR) <- Btyps
    for (Btyp in Btyps){
      aR[Btyp] <- 1- pkde1d(q=0,obj = rEV.kde.lst[[Btyp]])
    }
    
    P <- list(PmA=(1-pkde1d(q = rEV,obj = rEV.kde.lst[["prmABt"]])),
              PmR=(pkde1d(q = rEV,obj = rEV.kde.lst[["prmRBt"]])))
    
    pk <- matrix(NA,nrow=length(Btyps),ncol=length(k))
    rownames(pk) <- Btyps
    colnames(pk) <- k
    for (Btyp in Btyps){
      pk[Btyp,] <- pkde1d(q = k,obj = rEV.kde.lst[[Btyp]])
    }
 
    EV.class.prop <- matrix(NA,nrow=length(Btyps),ncol=(length(k)+1))
    rownames(EV.class.prop) <- Btyps
    for (Btyp in Btyps){
      EV.class.prop[Btyp,1] <- pk[Btyp,1]
      for (i in 1:(length(k)-1)){
        EV.class.prop[Btyp,i+1] <- pk[Btyp,i+1]-pk[Btyp,i]
      }
      EV.class.prop[Btyp,length(k)+1] <- 1-pk[Btyp,length(k)]
    }
    if (length(k)==2){
      colnames(EV.class.prop) <- c("strong4A","weak","strong4R")
    } 
    if (length(k)==4){
      colnames(EV.class.prop) <- c("strong4A","prog4A","weak","prog4R","strong4R")
    } 
    if (length(k)==6){
      colnames(EV.class.prop) <- c("vstrong4A","strong4A","prog4A","weak","prog4R","strong4R","vstrong4R")
    } 
    
    {#determining observed relative evidence class
      breaks <- c(-Inf,k,Inf)
      rEV.idx <- which(hist(x=rEV,breaks=breaks,plot=FALSE)$counts==1)
      if (length(k)==2){
        rEV.class <- switch(rEV.idx,
                            "Strong evidence for mA over mR",
                            "Weak evidence",
                            "Strong evidence for mR over mA")
        
      } 
      if (length(k)==4){
        rEV.class <- switch(rEV.idx,
                            "Strong evidence for mA over mR",
                            "Prognostic evidence for mA over mR",
                            "Weak evidence",
                            "Prognostic evidence for mR over mA",
                            "Strong evidence for mR over mA")
      } 
      if (length(k)==6){
        rEV.class <- switch(rEV.idx,
                            "Very strong evidence for mA over mR",
                            "Strong evidence for mA over mR",
                            "Prognostic evidence for mA over mR",
                            "Weak evidence",
                            "Prognostic evidence for mR over mA",
                            "Strong evidence for mR over mA",
                            "Very strong evidence for mR over mA")
                            
      } 
      attr(x = rEV,which = rEV.class) <- rEV.class
    }
    
    
  call=list(mR=mR,mA=mA,parmod=parmod,.DATA=.DATA,strta=strta,Breps=Breps,
            Btyps=Btyps,VI=VI,incl_bt0=incl_bt0,
            rEV.lim=rEV.lim,rEV.conf.lev=rEV.conf.lev,k=k,rEV.fun=rEV.fun,resCenter=resCenter)
  out1 <- list(rEV=rEV, aR=aR,EV.class.prop=EV.class.prop,DKest=DKest,rEV.CI.mat=rEV.CI.mat,DKest.CI.mat=DKest.CI.mat,
               rEV.cdf.mat=rEV.cdf.mat,P=P,pk=pk)
  out2 <- switch(sz.out.lev,
                 {#sz.out.lev=1
                   list(rEV.kde.lst=rEV.kde.lst, DKest.kde.lst=DKest.kde.lst)
                 },
                 {#sz.out.lev=2
                   for (Btyp in Btyps) {
                     rEV.kde.lst[[Btyp]] <- reduceSz.kde(rEV.kde.lst[[Btyp]],sz.lv = 2)
                     DKest.kde.lst[[Btyp]] <- reduceSz.kde(DKest.kde.lst[[Btyp]],sz.lv = 2)
                     
                   }
                   list(rEV.kde.lst=rEV.kde.lst, DKest.kde.lst=DKest.kde.lst)
                 },
                 {#sz.out.lev=3
                   for (Btyp in Btyps) {
                     rEV.kde.lst[[Btyp]] <- reduceSz.kde(rEV.kde.lst[[Btyp]],sz.lv = 3)
                     DKest.kde.lst[[Btyp]] <- reduceSz.kde(DKest.kde.lst[[Btyp]],sz.lv = 3)
                   }
                   list(rEV.kde.lst=rEV.kde.lst, DKest.kde.lst=DKest.kde.lst)
                 },
                 {#sz.out.lv=4
                   NULL#no kde object saved
                 }
  )
  out3 <- list(call=call, version=ver)
  out <- c(out1,out2,out3)
  } # end make return value (out)
  return(out)
} #end lm.rEV


is_nested <- function(m1, m2) {
  #code generated by copilot
  # Get the terms from each model
  terms1 <- attr(terms(m1), "term.labels")
  terms2 <- attr(terms(m2), "term.labels")
  
  # Check if the terms of m1 are all in m2
  is_m1_nested_in_m2 <- all(terms1 %in% terms2)
  
  # Check if the terms of m2 are all in m1
  is_m2_nested_in_m1 <- all(terms2 %in% terms1)
  
  if (is_m1_nested_in_m2 & !is_m2_nested_in_m1) {
    return("m1 is nested in m2")
  } else if (is_m2_nested_in_m1 & !is_m1_nested_in_m2) {
    return("m2 is nested in m1")
  } else {
    return("The models are not nested")
  }
}

xpnd.grid_points <- function(kde.obj){
  # If the # of grid_points in a save kde.obj has been reduce, the original is reconstructed
  out <- kde.obj
  if (length(out$grid_points) > 2) {
    strt=out$grid_points[1]
    end <- out$grid_points[length(out$grid_points)]
    lngth <- length(out$values)
    out$grid_points <- seq(from=strt,to=end,length.out=lngth)
  }
  return(out)
  }

#constructing dataframe for tree variety/pesticide effect on citrus yield aov
yield <- c(49, 39,   50, 55,  43, 38,  53, 48)
yield <- c(yield,55, 41,   67, 58,   53, 42,   85, 73)
yield <- c(yield,66, 68,   85, 92,   69, 62,   85, 99)
tree.var <-  as.factor(rep(1:3,each=8))
pesticd <- as.factor(rep(rep(1:4,each=2),3))
citrus.df <- data.frame(tree.var,pesticd,yield)
citrus.df
is.factor(citrus.df$tree.var)
is.factor(citrus.df$pesticd)

m1 <- lm(yield~tree.var+pesticd,data=citrus.df)
m2 <- lm(yield~tree.var+pesticd+tree.var:pesticd,data=citrus.df)

shazam(pln="mu")

tic()
tst <- lm.rEV(mR=m2,mA=m1,Xmod=NA,.DATA=citrus.df[,1:3],strta=NA,Breps=1024,
Btyps=c("prmABt","prmRBt","resBt","strtBt"),VI=TRUE,incl_bt0=TRUE,
rEV.lim=c(0.01,100),k=c(-7,7),rEV.fun=NA,resCenter=median, sz.out.lev =1)
toc()
object.size(tst)
wrkrs <- getDoParWorkers()
